# docker-compose.yml

networks:
  bmcp_network:
    driver: bridge

volumes:
  neo4j_data: # Note: Not currently used as we connect externally
  shared_code_input:
  shared_cpg_output:

services:
  # Neo4j service block removed to use external Neo4j Desktop instance
  code_fetcher_service:
    build:
      context: .
      dockerfile: ./code_fetcher_service/Dockerfile
    networks:
      - bmcp_network
    volumes:
      - shared_code_input:/shared_data/code_input
      - ./test_fixtures:/app/test_fixtures:ro
    ports:
      - "50051:50051"
    environment:
      GRPC_PORT: 50051
      SHARED_CODE_PATH: /shared_data/code_input
      PYTHONPATH: /app

  joern_analysis_service:
    build:
      context: .
      dockerfile: ./joern_analysis_service/Dockerfile
    networks:
      - bmcp_network
    volumes:
      - shared_code_input:/analysis-data/code:ro
      - shared_cpg_output:/analysis-data/cpg
      - ./test_fixtures:/app/test_fixtures:ro
    ports:
      - "50053:50053"
    environment:
      GRPC_PORT: 50053
      _JAVA_OPTS: ${JOERN_JAVA_OPTS:--Xmx4g}
    depends_on:
      - code_fetcher_service

  treesitter_sql_analyzer:
    build:
      context: .
      dockerfile: ./treesitter_sql_analyzer/Dockerfile
    networks:
      - bmcp_network
    volumes:
      - shared_code_input:/shared_data/code_input:ro
      - ./test_fixtures:/app/test_fixtures:ro
    ports:
      - "50054:50054"
    environment:
      GRPC_PORT: 50054
    healthcheck:
      # Use netcat (nc) to check if the port is listening
      test: ["CMD", "nc", "-z", "localhost", "50054"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 15s # Give time for server to start before checking
    depends_on:
      - code_fetcher_service

  python_analyzer_service:
    build:
      context: .
      dockerfile: ./python_analyzer_service/Dockerfile
    networks:
      - bmcp_network
    volumes:
      - shared_code_input:/shared_data/code_input:ro
      - ./test_fixtures:/app/test_fixtures:ro
    ports:
      - "50056:50056"
    environment:
      GRPC_PORT: 50056
      PYTHONPATH: /app:/app/generated/src
    # TODO: Add healthcheck using grpcio-health-checking or nc if needed
    depends_on:
      - code_fetcher_service

  javascript_analyzer_service:
    build:
      context: .
      dockerfile: ./javascript_analyzer_service/Dockerfile
    networks:
      - bmcp_network
    volumes:
      - shared_code_input:/shared_data/code_input:ro
      - ./test_fixtures:/app/test_fixtures:ro
    ports:
      - "50057:50057"
    environment:
      GRPC_PORT: 50057
    healthcheck:
      # Use netcat (nc) to check if the port is listening
      test: ["CMD", "nc", "-z", "localhost", "50057"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 15s
    depends_on:
      - code_fetcher_service

  typescript_analyzer_service:
    build:
      context: .
      dockerfile: ./typescript_analyzer_service/Dockerfile
    networks:
      - bmcp_network
    volumes:
      - shared_code_input:/shared_data/code_input:ro
      - ./test_fixtures:/app/test_fixtures:ro
    ports:
      - "50058:50058"
    environment:
      GRPC_PORT: 50058
    healthcheck:
      # Use netcat (nc) to check if the port is listening
      test: ["CMD", "nc", "-z", "localhost", "50058"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 15s
    depends_on:
      - code_fetcher_service

  neo4j_ingestion_service:
    build:
      context: .
      dockerfile: ./neo4j_ingestion_service/Dockerfile
    networks:
      - bmcp_network
    volumes:
      - shared_cpg_output:/shared_data/cpg_output:ro
    ports:
      - "50055:50055"
    environment:
      GRPC_PORT: 50055
      SHARED_CPG_PATH: /shared_data/cpg_output
      NEO4J_URI: bolt://host.docker.internal:7687
      NEO4J_USER: ${NEO4J_USER:-neo4j} # Allow override from .env
      NEO4J_PASSWORD: ${NEO4J_PASSWORD:-test1234} # Allow override from .env
      PYTHONPATH: /app
    # TODO: Add healthcheck using grpcio-health-checking or nc if needed
    depends_on:
      # Dependency on internal neo4j service removed
      - joern_analysis_service # Wait for Joern service to start

  api_gateway:
    build:
      context: .
      dockerfile: ./api_gateway/Dockerfile
    networks:
      - bmcp_network
    ports:
      - "8000:8000"
    volumes:
      - ./test_fixtures:/app/test_fixtures:ro
    environment:
      HTTP_PORT: 8000
      CODE_FETCHER_SERVICE_ADDRESS: code_fetcher_service:50051
      JOERN_ANALYSIS_SERVICE_ADDRESS: joern_analysis_service:50053
      NEO4J_INGESTION_SERVICE_ADDRESS: neo4j_ingestion_service:50055
      SQL_ANALYSIS_SERVICE_ADDRESS: treesitter_sql_analyzer:50054
      PYTHON_ANALYZER_ADDRESS: python_analyzer_service:50056
      JAVASCRIPT_ANALYZER_ADDRESS: javascript_analyzer_service:50057
      TYPESCRIPT_ANALYZER_ADDRESS: typescript_analyzer_service:50058
      NEO4J_URI: bolt://host.docker.internal:7687
      NEO4J_USER: ${NEO4J_USER:-neo4j} # Allow override from .env
      NEO4J_PASSWORD: ${NEO4J_PASSWORD:-test1234} # Allow override from .env
      PROJECT_BASE_PATH: /app
      PYTHONPATH: /app:/app/generated/src
    depends_on:
      code_fetcher_service:
        condition: service_started # Basic dependency
      joern_analysis_service:
        condition: service_started # Basic dependency (no healthcheck yet)
      neo4j_ingestion_service:
        condition: service_started # Basic dependency (no healthcheck yet)
      treesitter_sql_analyzer:
        condition: service_healthy # Wait for TCP healthcheck
      python_analyzer_service:
        condition: service_started # Basic dependency (no healthcheck yet)
      javascript_analyzer_service:
        condition: service_healthy # Wait for TCP healthcheck
      typescript_analyzer_service:
        condition: service_healthy # Wait for TCP healthcheck
