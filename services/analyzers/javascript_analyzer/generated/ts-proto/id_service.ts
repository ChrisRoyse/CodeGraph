// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: id_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "bmcp.id_service";

/** GenerateIdRequest contains all context needed for ID generation */
export interface GenerateIdRequest {
  /** Path to the file containing the entity, relative to the monitored root */
  filePath: string;
  /** Type of entity (Function, Class, Method, etc.) */
  entityType: string;
  /** Name of the entity */
  name: string;
  /** Canonical ID of the parent entity (optional) */
  parentCanonicalId: string;
  /** Parameter types for functions/methods (optional) */
  paramTypes: string[];
  /** Language hint to help with ID generation (optional) */
  languageHint: string;
}

/** GenerateIdResponse contains the generated IDs */
export interface GenerateIdResponse {
  /** The canonical ID for the entity */
  canonicalId: string;
  /** The global ID (GID) for the entity */
  gid: string;
}

/** ParseIdRequest contains the ID string to parse */
export interface ParseIdRequest {
  /** The ID string to parse (can be canonical ID or GID) */
  idString: string;
}

/** ParseIdResponse contains the components of the parsed ID */
export interface ParseIdResponse {
  /** Path to the file containing the entity */
  filePath: string;
  /** Type of entity */
  entityType: string;
  /** Name of the entity */
  name: string;
  /** Canonical ID of the parent entity (if any) */
  parentCanonicalId: string;
  /** Parameter types (if applicable) */
  paramTypes: string[];
  /** Original canonical ID (if a GID was parsed) */
  canonicalId: string;
  /** Language prefix (if a GID was parsed) */
  languagePrefix: string;
  /** Original GID (if a canonical ID was parsed) */
  gid: string;
}

function createBaseGenerateIdRequest(): GenerateIdRequest {
  return { filePath: "", entityType: "", name: "", parentCanonicalId: "", paramTypes: [], languageHint: "" };
}

export const GenerateIdRequest: MessageFns<GenerateIdRequest> = {
  encode(message: GenerateIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    if (message.entityType !== "") {
      writer.uint32(18).string(message.entityType);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.parentCanonicalId !== "") {
      writer.uint32(34).string(message.parentCanonicalId);
    }
    for (const v of message.paramTypes) {
      writer.uint32(42).string(v!);
    }
    if (message.languageHint !== "") {
      writer.uint32(50).string(message.languageHint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filePath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parentCanonicalId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paramTypes.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.languageHint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateIdRequest {
    return {
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
      entityType: isSet(object.entityType) ? globalThis.String(object.entityType) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parentCanonicalId: isSet(object.parentCanonicalId) ? globalThis.String(object.parentCanonicalId) : "",
      paramTypes: globalThis.Array.isArray(object?.paramTypes)
        ? object.paramTypes.map((e: any) => globalThis.String(e))
        : [],
      languageHint: isSet(object.languageHint) ? globalThis.String(object.languageHint) : "",
    };
  },

  toJSON(message: GenerateIdRequest): unknown {
    const obj: any = {};
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parentCanonicalId !== "") {
      obj.parentCanonicalId = message.parentCanonicalId;
    }
    if (message.paramTypes?.length) {
      obj.paramTypes = message.paramTypes;
    }
    if (message.languageHint !== "") {
      obj.languageHint = message.languageHint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateIdRequest>, I>>(base?: I): GenerateIdRequest {
    return GenerateIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateIdRequest>, I>>(object: I): GenerateIdRequest {
    const message = createBaseGenerateIdRequest();
    message.filePath = object.filePath ?? "";
    message.entityType = object.entityType ?? "";
    message.name = object.name ?? "";
    message.parentCanonicalId = object.parentCanonicalId ?? "";
    message.paramTypes = object.paramTypes?.map((e) => e) || [];
    message.languageHint = object.languageHint ?? "";
    return message;
  },
};

function createBaseGenerateIdResponse(): GenerateIdResponse {
  return { canonicalId: "", gid: "" };
}

export const GenerateIdResponse: MessageFns<GenerateIdResponse> = {
  encode(message: GenerateIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.canonicalId !== "") {
      writer.uint32(10).string(message.canonicalId);
    }
    if (message.gid !== "") {
      writer.uint32(18).string(message.gid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.canonicalId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateIdResponse {
    return {
      canonicalId: isSet(object.canonicalId) ? globalThis.String(object.canonicalId) : "",
      gid: isSet(object.gid) ? globalThis.String(object.gid) : "",
    };
  },

  toJSON(message: GenerateIdResponse): unknown {
    const obj: any = {};
    if (message.canonicalId !== "") {
      obj.canonicalId = message.canonicalId;
    }
    if (message.gid !== "") {
      obj.gid = message.gid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateIdResponse>, I>>(base?: I): GenerateIdResponse {
    return GenerateIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateIdResponse>, I>>(object: I): GenerateIdResponse {
    const message = createBaseGenerateIdResponse();
    message.canonicalId = object.canonicalId ?? "";
    message.gid = object.gid ?? "";
    return message;
  },
};

function createBaseParseIdRequest(): ParseIdRequest {
  return { idString: "" };
}

export const ParseIdRequest: MessageFns<ParseIdRequest> = {
  encode(message: ParseIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.idString !== "") {
      writer.uint32(10).string(message.idString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParseIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.idString = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParseIdRequest {
    return { idString: isSet(object.idString) ? globalThis.String(object.idString) : "" };
  },

  toJSON(message: ParseIdRequest): unknown {
    const obj: any = {};
    if (message.idString !== "") {
      obj.idString = message.idString;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParseIdRequest>, I>>(base?: I): ParseIdRequest {
    return ParseIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParseIdRequest>, I>>(object: I): ParseIdRequest {
    const message = createBaseParseIdRequest();
    message.idString = object.idString ?? "";
    return message;
  },
};

function createBaseParseIdResponse(): ParseIdResponse {
  return {
    filePath: "",
    entityType: "",
    name: "",
    parentCanonicalId: "",
    paramTypes: [],
    canonicalId: "",
    languagePrefix: "",
    gid: "",
  };
}

export const ParseIdResponse: MessageFns<ParseIdResponse> = {
  encode(message: ParseIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    if (message.entityType !== "") {
      writer.uint32(18).string(message.entityType);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.parentCanonicalId !== "") {
      writer.uint32(34).string(message.parentCanonicalId);
    }
    for (const v of message.paramTypes) {
      writer.uint32(42).string(v!);
    }
    if (message.canonicalId !== "") {
      writer.uint32(50).string(message.canonicalId);
    }
    if (message.languagePrefix !== "") {
      writer.uint32(58).string(message.languagePrefix);
    }
    if (message.gid !== "") {
      writer.uint32(66).string(message.gid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParseIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filePath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parentCanonicalId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paramTypes.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.canonicalId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.languagePrefix = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.gid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParseIdResponse {
    return {
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
      entityType: isSet(object.entityType) ? globalThis.String(object.entityType) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parentCanonicalId: isSet(object.parentCanonicalId) ? globalThis.String(object.parentCanonicalId) : "",
      paramTypes: globalThis.Array.isArray(object?.paramTypes)
        ? object.paramTypes.map((e: any) => globalThis.String(e))
        : [],
      canonicalId: isSet(object.canonicalId) ? globalThis.String(object.canonicalId) : "",
      languagePrefix: isSet(object.languagePrefix) ? globalThis.String(object.languagePrefix) : "",
      gid: isSet(object.gid) ? globalThis.String(object.gid) : "",
    };
  },

  toJSON(message: ParseIdResponse): unknown {
    const obj: any = {};
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parentCanonicalId !== "") {
      obj.parentCanonicalId = message.parentCanonicalId;
    }
    if (message.paramTypes?.length) {
      obj.paramTypes = message.paramTypes;
    }
    if (message.canonicalId !== "") {
      obj.canonicalId = message.canonicalId;
    }
    if (message.languagePrefix !== "") {
      obj.languagePrefix = message.languagePrefix;
    }
    if (message.gid !== "") {
      obj.gid = message.gid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParseIdResponse>, I>>(base?: I): ParseIdResponse {
    return ParseIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParseIdResponse>, I>>(object: I): ParseIdResponse {
    const message = createBaseParseIdResponse();
    message.filePath = object.filePath ?? "";
    message.entityType = object.entityType ?? "";
    message.name = object.name ?? "";
    message.parentCanonicalId = object.parentCanonicalId ?? "";
    message.paramTypes = object.paramTypes?.map((e) => e) || [];
    message.canonicalId = object.canonicalId ?? "";
    message.languagePrefix = object.languagePrefix ?? "";
    message.gid = object.gid ?? "";
    return message;
  },
};

/** IdService provides centralized ID generation and parsing */
export interface IdService {
  /** GenerateId generates a canonical ID and GID for a given entity */
  GenerateId(request: GenerateIdRequest): Promise<GenerateIdResponse>;
  /** ParseId parses a canonical ID or GID into its components */
  ParseId(request: ParseIdRequest): Promise<ParseIdResponse>;
}

export const IdServiceServiceName = "bmcp.id_service.IdService";
export class IdServiceClientImpl implements IdService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || IdServiceServiceName;
    this.rpc = rpc;
    this.GenerateId = this.GenerateId.bind(this);
    this.ParseId = this.ParseId.bind(this);
  }
  GenerateId(request: GenerateIdRequest): Promise<GenerateIdResponse> {
    const data = GenerateIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GenerateId", data);
    return promise.then((data) => GenerateIdResponse.decode(new BinaryReader(data)));
  }

  ParseId(request: ParseIdRequest): Promise<ParseIdResponse> {
    const data = ParseIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ParseId", data);
    return promise.then((data) => ParseIdResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
